'*******************************************************************************
'
'   PIC 16F1828
'   Horloge interne (INTOSC I/O)
'   Frequence 16 MHz
'   CONFIG PROJECT => MCLRE OFF
'   Mode programmation : Master clear = Disabled
'
' ******************************************************************************
'   Programme pour PIC 16F1828 à 16MHz avec LCD
'
'*******************************************************************************
'
'   Date de revision :
'
'*******************************************************************************
'
'
'*******************************************************************************

program CPENCA_Faker


#DEFINE PIC18F25k50
'#DEFINE WITH_INERTIA
#DEFINE WITH_DIFFERENTIAL
'#DEFINE ADC_16BITS

#IFDEF PIC18F25k50 THEN
symbol ENC_A_P = PORTB.0
symbol ENC_A_M = PORTB.1
symbol ENC_B_P = PORTB.2
symbol ENC_B_M = PORTB.3
symbol ENC_Z_P = PORTB.3
symbol ENC_Z_M = PORTB.4
symbol INPUT_VOLT = PORTA.3
symbol LED_STATUS = PORTA.5
#ENDIF

#IFDEF PIC18F25k22 THEN

#ENDIF

#IFDEF ADC_16BITS
dim VOLTAGE_TARGET as word
dim VOLTAGE as word
#ELSE
dim VOLTAGE_TARGET as byte
dim VOLTAGE as byte
#ENDIF

#IFDEF WITH_INERTIA
       #IFDEF ADC_16BITS
          dim VOLTAGE_TARGET_M1 as word
          dim VOLTAGE_TARGET_M2 as word
          dim VOLTAGE_TARGET_M3 as word
       #ELSE
          dim VOLTAGE_TARGET_M1 as byte
          dim VOLTAGE_TARGET_M2 as byte
          dim VOLTAGE_TARGET_M3 as byte
       #ENDIF
#ENDIF


'*******************************************************************************
'
'  CODE GENERE depuis https://jsbin.com/jasazaf/edit?js,output
'
'*******************************************************************************

'********************************************************
'--- Config---
' freq=48000000hz
' cpr=4000pulse/tr
' Kv=300rpm/V
' adcPrecision=8
'--- Info  ---
' 1 cycle = 83.33333333333334 ns
' 1V = 20000 pulse/s
' 1V = 600 cycle/pulse


'--- Code généré---
const ADC_PRECISION as byte = 255
' ENCODER CPR = nbr de pulse par tour d'encoder
const ENCODER_CPR as word = 4000
' CYCLE_MAPPING = 10 * nbr de cycle necessaire pour un quart de pulse
const CYCLE_MAPPING as word[128] = (1535,190,95,63,47,38,31,27,23,21,19,17,15,14,13,12,11,11,10,10,9,9,8,8,7,7,7,7,6,6,6,6,5,5,5,5,5,5,5,4,4,4,4,4,4,4,4,4,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1)

'*******************************************************************************
'
'  PROCEDURE INTERRUPTION
'
'*******************************************************************************
dim ENCODER_IN_MOTION as boolean
dim CLOCK_ROTATION as boolean
dim QUARTER_PERIOD_LOW as byte
dim QUARTER_PERIOD_HIGH as byte

dim NBR_CYCLE_H as byte
dim NBR_CYCLE_L as byte

sub procedure interrupt
  dim NBR_CYCLE as word

  if INTCON.TMR0IF = 1 then
    ' interruption sur timer0 overflow

    ' Clean interruption flag
    INTCON.TMR0IF = 0
    ' Desactive timer 0 interruption
    INTCON.TMR0IE=0
    ' START ADC conversion qui va declencer une interruption
    ADCON0.1=1
  end if

  if PIR1.ADIF = 1 then
    ' interruption sur ADC convertion

    ' Sauvegarde la valeur du voltage (sur 9bits uniquement)
    #IFDEF ADC_16BITS
        VOLTAGE_TARGET=word(ADRESH<<8) + ADRESL
    #ELSE
        VOLTAGE_TARGET=ADRESH
    #ENDIF


    #IFDEF WITH_INERTIA
      '   VOLTAGE = VOLTAGE_TARGET_M3/2 + VOLTAGE_TARGET_M2/4 + VOLTAGE_TARGET_M1/8 + VOLTAGE_TARGET/8
      ''VOLTAGE = ((VOLTAGE_TARGET_M3>>1) + (VOLTAGE_TARGET_M2>>2)) + ((VOLTAGE_TARGET_M1>>3) + (VOLTAGE_TARGET>>3))
      'Propagate delays
      ''VOLTAGE_TARGET_M3=VOLTAGE_TARGET_M2
      ''VOLTAGE_TARGET_M2=VOLTAGE_TARGET_M1
      'VOLTAGE_TARGET_M1=VOLTAGE_TARGET

      VOLTAGE = VOLTAGE>>1 + VOLTAGE_TARGET>>1

    #ELSE
      VOLTAGE = VOLTAGE_TARGET
    #ENDIF

    ENCODER_IN_MOTION=true
    
    'if VOLTAGE > 128 then
'        CLOCK_ROTATION=true
'        NBR_CYCLE = CYCLE_MAPPING[VOLTAGE-128]
'    else
'        if VOLTAGE < 127 then
'           CLOCK_ROTATION=false
'           NBR_CYCLE = CYCLE_MAPPING[127-VOLTAGE]
'        else
'           ENCODER_IN_MOTION=false
'           NBR_CYCLE = 0x0000
'        end if
'    end if
    
    if VOLTAGE > (ADC_PRECISION/2) then
        CLOCK_ROTATION=true
        NBR_CYCLE = CYCLE_MAPPING[VOLTAGE-(ADC_PRECISION/2+1)]
    else
        if VOLTAGE < (ADC_PRECISION/2) then
           CLOCK_ROTATION=false
           NBR_CYCLE = CYCLE_MAPPING[ADC_PRECISION/2-VOLTAGE]
        else
           ENCODER_IN_MOTION=false
        end if
    end if

    NBR_CYCLE_H = NBR_CYCLE >> 8
    NBR_CYCLE_L = NBR_CYCLE
    
    ' Clean interruption flag
    PIR1.ADIF = 0
    ' Prepare timer0 interruption
    TMR0L=0
    ' Enable timer 0 interruption to trigger ADC conversion later
    INTCON.TMR0IE=1
     
  end if
end sub

'*******************************************************************************
'
'  PROCEDURES
'
'*******************************************************************************

' Procedure pour attendre une grande valeur de cycle
sub procedure wait(dim high as byte,dim low as byte)
   dim k as integer
   if high>0 then
     k = 0
     while k < high
      Delay_Cyc(0xFF)
      Inc(k)
     wend
   end if
   if low>1 then
      Delay_Cyc(low)
   else
       ' ref limitation of  Delay_Cyc
       if low=1 then
          asm
            nop
            nop
            nop
            nop
            nop
            nop
            nop
            nop
            nop
            nop
          end asm
       end if
   end if
end sub


'*******************************************************************************
'
'  PROGRAMME PRINCIPAL
'
'*******************************************************************************
main:
  dim POSITION_COUNTER as integer

   TRISA = %00001000
   TRISA.B3 = 1                        ' A3 en input
   TRISB = %00000000                   ' B en sortie
   TRISC = %00000000                   ' C3 en input

   PORTA = %00000000                   ' initialize Port A
   PORTB = %00000000                   ' initialize Port B
   PORTC = %00000000                   ' initialize Port C

#IFDEF PIC18F25k50 THEN
   ' -----------------------------------------------------------
   ' Use 16Mhz internal clock with PLL4x to get 48Mhz clock
   ' CONFIG1L : 0x0023
   ' CONFIG1H : 0x0008
   OSCCON = 0x00                 ' Oscillator control register
   OSCCON.IRCF2 = 1                   ' Internal RC Oscillator freq HFINTOSC 16Mhz
   OSCCON.IRCF1 = 1
   OSCCON.IRCF0 = 1
   OSCCON.SCS1 = 0                    ' System clock set to primary clock
   OSCCON.SCS0 = 0
   
   ' -----------------------------------------------------------
   ' Initialize A/D module
   ADCON0 = 0x00                      ' A/D Control register 0
   ADCON0.B6 = 0                      ' Analog channel set to AN3
   ADCON0.B5 = 0
   ADCON0.B4 = 0
   ADCON0.B3 = 1
   ADCON0.B2 = 1
   ADCON0.ADON = 1                    ' Enbale ADC
   
   ADCON1 = 0x00                      ' A/D Control register 1
   ADCON1.PVCFG1 = 0                  ' Vref+ connected to AVDD
   ADCON1.PVCFG0 = 0
   ADCON1.NVCFG1 = 0                  ' Vref- connected to AVSS
   ADCON1.NVCFG0 = 0

   ADCON2 = 0x00                      ' A/D Control register 2
   ADCON2.ADFM = 0                    ' Right alignement
   ADCON2.ACQT2 = 1                   ' Acquisition time = 8 TAD
   ADCON2.ACQT1 = 0
   ADCON2.ACQT0 = 0
   ADCON2.ADCS2 = 0                   ' Conversion clock = Frc
   ADCON2.ADCS1 = 1
   ADCON2.ADCS0 = 1
#ENDIF

   CM1CON0.7=0                        ' comparateurs arrétés
   CM2CON0.7=0                        ' comparateurs arrétés

   ' Configure l'interruption sur Timer0
   INTCON.TMR0IE=0                      'Desactive l'interruption sur timer0 (elle est activee plus tard)
   T0CON.TMR0ON = 1 'Enable time0
   T0CON.T08BIT = 1 'Configure as 8bit counter
   T0CON.T0CS = 0                'T0CS: TMR0 Clock Source Select bit| 0 = Internal instruction cycle clock (FOSC/4)
   T0CON.PSA = 0
   T0CON.T0PS2 = 1                 'Prescaler Rate Select bits
   T0CON.T0PS1 = 1                 'Active un prescale 1/128 pour le timer0 afin d'augmenter la periode
   T0CON.T0PS0 = 0

   ' Configure l'interruption sur ADC
   INTCON.PEIE = 1                    ' Enable peripheral interrupt
   PIE1.ADIE = 1                       'Enable ADC Interrupt

   ' INIT variables
   POSITION_COUNTER=0
   CLOCK_ROTATION=true
   ENCODER_IN_MOTION=false
   LATB=%00101010
   VOLTAGE= ADC_PRECISION/2               ' START with a 0V VOLTAGE

   ' Fait clignoter la LED de status
   LED_STATUS = 1
   delay_ms(50)
   LED_STATUS = 0
   delay_ms(50)
   LED_STATUS = 1
   delay_ms(50)
   LED_STATUS = 0
   delay_ms(200)
'
'   LED_STATUS = 1
'   delay_ms(100)
'   LED_STATUS = 0
'   delay_ms(100)
'   LED_STATUS = 1
'   delay_ms(100)
'   LED_STATUS = 0
'   delay_ms(400)

   ' La valeur de tension de commande est récupérée de manière asynchrone
   ' par l'association du timer0 et de la mesure ADC en interruption.
   INTCON.GIE = 1 ' Enable global interrupt
   ADCON0.1=1 ' START a ADC conversion

   while TRUE
     IF ENCODER_IN_MOTION=true then
        ' Recupere le nombre de cycle associe a la tension de consigne actuelle
        IF CLOCK_ROTATION = true then
           ' Calcule la nouvelle position ( -ENCODER_CPR<POSITION_COUNTER<ENCODER_CPR)
           ' pour envoyer un signal de tour quand ENCODER_CPR=0
           Inc(POSITION_COUNTER)
           if POSITION_COUNTER = ENCODER_CPR then
             POSITION_COUNTER = 0
           end if

          ' SENS HORAIRE
          ' AP----____
          ' AM____----
          ' BP__----__
          ' BM--____--
          LATB=%00101001
          wait(NBR_CYCLE_H,NBR_CYCLE_L)

          if POSITION_COUNTER = 0 then
             LATB=%00010101
          else
             LATB=%00100101
          end if
          wait(NBR_CYCLE_H,NBR_CYCLE_L)

          LATB=%00100110
          wait(NBR_CYCLE_H,NBR_CYCLE_L)

          LATB=%00101010
          wait(NBR_CYCLE_H,NBR_CYCLE_L)
       else
          ' Calcule la nouvelle position ( -ENCODER_CPR<POSITION_COUNTER<ENCODER_CPR)
          ' pour envoyer un signal de tour quand ENCODER_CPR=0
          Dec(POSITION_COUNTER)
          if POSITION_COUNTER = -ENCODER_CPR then
              POSITION_COUNTER = 0
           end if

          ' SENS ANTIHORAIRE
          ' AP__----__
          ' AM--____--
          ' BP----____
          ' BM____----
          LATB=%00100110
          wait(NBR_CYCLE_H,NBR_CYCLE_L)

          if POSITION_COUNTER = 0 then
             LATB=%00010101
          else
             LATB=%00100101
          end if
          wait(NBR_CYCLE_H,NBR_CYCLE_L)

          LATB=%00101001
          wait(NBR_CYCLE_H,NBR_CYCLE_L)

          LATB=%00101010
          wait(NBR_CYCLE_H,NBR_CYCLE_L)
       end if
     else
         ' Etant dans une zone morte, on ne genere aucun pulse
         ' on attend juste qq cycle avant de recommencer la boucle
         Delay_Cyc(0x10)
     end if
   wend
end.